<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lab 1 | Artemis and Bluetooth</title>

  <!-- Match your site theme -->
  <link href="../css/styles.css" rel="stylesheet" />

  <style>
    /* Simple readable lab-page styling on top of your theme */
    .lab-container { max-width: 980px; margin: 0 auto; padding: 2rem 1rem; }
    .lab-title { margin-top: 1rem; }
    .pill { display:inline-block; padding:.2rem .6rem; border-radius:999px; font-size:.85rem; }
    .pill-ok { background:#e8f5e9; }
    .pill-todo { background:#fff3e0; }
    .cardish { border: 1px solid rgba(0,0,0,.12); border-radius: 12px; padding: 1rem; margin: 1rem 0; }
    pre { background: rgba(0,0,0,.05); padding: .9rem; border-radius: 10px; overflow:auto; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    img { max-width: 100%; border-radius: 10px; }
    .small { color: rgba(0,0,0,.65); font-size: .95rem; }
    .toc a { text-decoration: none; }
    .toc a:hover { text-decoration: underline; }
    table { width:100%; border-collapse: collapse; margin: .75rem 0; }
    th, td { border: 1px solid rgba(0,0,0,.15); padding: .5rem; text-align:left; vertical-align: top; }
    th { background: rgba(0,0,0,.05); }
  </style>
</head>

<body>
  <div class="lab-container">
    <!-- Header -->
    <a href="../index.html">← Back to Home</a>

    <h1 class="lab-title">Lab 1: The Artemis Board and Bluetooth</h1>
    <p class="small">
      Course: ECE 5160 Fast Robots (Spring 2026) <br/>
      Student: Hetao Yin <br/>
    </p>

    <div class="cardish toc">
      <b>Table of Contents</b>
      <ol>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#prelab">Prelab</a></li>
        <li><a href="#tasks">Lab Tasks (1–8)</a></li>
        <li><a href="#discussion">Discussion</a></li>
        <li><a href="#grad">5000-level (Optional)</a></li>
        <li><a href="#refs">References</a></li>
      </ol>
      <p class="small">
        NOTE: Keep the final write-up under <b>1000 words</b> (excluding code blocks/captions if you want to be safe). :contentReference[oaicite:1]{index=1}
      </p>
    </div>

    <!-- 1) Overview -->
    <section id="overview" class="cardish">
      <h2>1. Overview</h2>
      <p>
        This lab introduces the SparkFun RedBoard Artemis Nano and establishes a basic
Bluetooth Low Energy (BLE) communication pipeline between the Artemis board and a
host computer. In Lab 1A, the Arduino development environment was set up and basic
Artemis programming tasks were completed to verify correct board configuration and
serial communication. In Lab 1B, a BLE-based communication framework was implemented,
allowing a laptop (Python/Jupyter) to act as a central device and exchange commands
and data with the Artemis board acting as a peripheral. This framework forms the
foundation for reliable data transmission and command-based interaction used in
subsequent labs.

      <h3>Hardware / Software</h3>
      <ul>
        <li><b>Board:</b> SparkFun RedBoard Artemis Nano</li>
        <li><b>IDE:</b> Arduino IDE</li>
        <li><b>Python:</b> venv + JupyterLab + bleak (BLE)</li>
      </ul>

    </section>

    <!-- 2) Prelab -->
    <section id="prelab" class="cardish">
      <h2>2. Prelab</h2>

      <h3>2.1 Blink</h3>
      <p>
      <video width="480" controls>
  <source src="videos/blink.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<p class="small">  
      </p>

<h3>2.2 Serial</h3>
      <p>
<img src="images/serial.png" alt="Serial monitor output for blink test">

<p class="small">
    </p>    
      <h3>2.3 AnalogRead</h3>
      <p>
<img src="images/analogRead.png" alt="Analog read output">

<p class="small">

    </p>  
      <h3>2.4 MircrophoneOut</h3>
      <p>
<img src="images/MicrophoneOutput.png" alt="Microphone output values">

<p class="small">
    </p>  
      </div>


    </section>

    <!-- 3) Tasks -->
    <section id="tasks" class="cardish">
      <h2>3. Lab Tasks</h2>
      <p class="small">
        Below follows tasks 1–8 required by the Lab 1B handout. For each task:
        explain what you changed, show evidence (screenshot/video), and include minimal code snippets. :contentReference[oaicite:4]{index=4}
      </p>

      <!-- Task 1 -->
<div class="cardish">
  <h3>Task 1 — ECHO string (PC → Artemis → PC)</h3>

  <ul>
    <li><b>Command used:</b> <code>ECHO</code></li>
    <li><b>Expected behavior:</b> The PC sends a string to the Artemis board, and the Artemis replies with an augmented version of the string.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task1.png" alt="ECHO command code">
    <p class="small">Figure 1: Arduino-side ECHO handling and reply construction.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task1_.png" alt="ECHO command output">
    <p class="small">Figure 2: ECHO command sent from the PC and augmented reply received from Artemis.</p>
  </div>
</div>

<!-- Task 2 -->
<div class="cardish">
  <h3>Task 2 — SEND_THREE_FLOATS (extract 3 floats on Artemis)</h3>

  <ul>
    <li><b>Command used:</b> <code>SEND_THREE_FLOATS</code></li>
    <li><b>Expected behavior:</b> The PC sends three float values, and the Artemis parses and prints/returns the extracted floats.</b></li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task2.png" alt="SEND_THREE_FLOATS code">
    <p class="small">Figure 3: Arduino-side parsing of three floats using RobotCommand/EString.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task2_.png" alt="SEND_THREE_FLOATS output">
    <p class="small">Figure 4: Sending three floats from the PC and confirming the parsed values on Artemis.</p>
  </div>
</div>


     <!-- Task 3 -->
<div class="cardish">
  <h3>Task 3 — GET_TIME_MILLIS (reply “T:123456”)</h3>

  <ul>
    <li><b>Command used:</b> <code>GET_TIME_MILLIS</code></li>
    <li><b>Expected behavior:</b> The Artemis returns the current timestamp (in milliseconds) formatted as <code>T:&lt;millis&gt;</code> over BLE.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task3.png" alt="GET_TIME_MILLIS code">
    <p class="small">Figure 5: Arduino-side GET_TIME_MILLIS command handling and timestamp string formatting.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task3_.png" alt="GET_TIME_MILLIS output">
    <p class="small">Figure 6: GET_TIME_MILLIS request sent from the PC and <code>T:&lt;millis&gt;</code> response received from Artemis.</p>
  </div>
</div>

      <!-- Task 4 -->
<div class="cardish">
  <h3>Task 4 — Python notification handler (parse time from string)</h3>

  <ul>
    <li><b>Task:</b> Set up a BLE notification handler in Python to receive the Artemis TX string characteristic.</li>
    <li><b>Expected behavior:</b> The callback decodes the incoming string and extracts the timestamp from messages formatted as <code>T:&lt;millis&gt;</code>.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Python)</b>
    <img src="images/task4.png" alt="Python notification handler code">
    <p class="small">Figure 7: Python notification callback implementation for receiving and parsing <code>T:&lt;millis&gt;</code> strings.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task4_.png" alt="Notification output showing parsed timestamps">
    <p class="small">Figure 8: Notifications received from Artemis and timestamps successfully extracted in the callback.</p>
  </div>
</div>

<div class="cardish">
  <h3>Task 5 — Timestamp streaming & data rate</h3>

  <ul>
    <li>
      <b>Task:</b> Continuously send the current timestamp from the Artemis to the laptop using BLE
      notifications and determine the effective data transfer rate.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    A non-blocking loop on the Artemis uses <code>millis()</code> to periodically send the current
    timestamp as a BLE notification. On the laptop, a Python notification handler extracts the
    timestamp and counts how many messages are received over a fixed time window.
  </p>

  <!-- Code -->
  <img src="images/task5.png" alt="Arduino timestamp loop and Python handler code">
  <p class="small">
    Figure 9: Arduino loop transmitting <code>millis()</code> timestamps and Python notification handler.
  </p>

  <!-- Result -->
  <img src="images/task5_.png" alt="Timestamp output and rate calculation">
  <p class="small">
    Figure 10: Consecutive timestamps received on the laptop and calculated message rate.
  </p>

  <b>Results and Analysis</b>
  <p>
    Over approximately 5 seconds, 180 timestamp messages were received, corresponding to an average
    rate of <b>~35 messages per second</b>. Each message contains a timestamp string of about 8 bytes,
    resulting in an effective data transfer rate of approximately <b>2 kbps</b>.
  </p>
</div>


     <div class="cardish">
  <h3>Task 6 — Store timestamps in an array and send in batch</h3>

  <ul>
    <li>
      <b>Task:</b> Store timestamp data on the Artemis in a global array, then transmit the entire
      dataset to the laptop using a dedicated BLE command.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    A global array is defined on the Artemis to store timestamp values generated using
    <code>millis()</code>. During normal operation, the main loop periodically records timestamps
    into this array instead of immediately sending them over BLE. An index variable is used to
    track the current position in the array, and additional logic ensures the array is not overfilled.
  </p>
  <p>
    Once the array is full, a new command (<code>SEND_TIME_DATA</code>) is used to iterate through
    the stored timestamps and send each value as a string over a BLE notification. This allows
    timestamp data to be transmitted in a batch rather than continuously.
  </p>

  <!-- Code: Arduino -->
  <img src="images/task6_1.png" alt="Arduino timestamp array and SEND_TIME_DATA command">
  <p class="small">
    Figure 11: Arduino implementation showing a global timestamp array, controlled insertion logic,
    and the <code>SEND_TIME_DATA</code> command used to transmit stored values.
  </p>

  <!-- Code: Python -->
  <img src="images/task6_2.png" alt="Python code collecting timestamp data">
  <p class="small">
    Figure 12: Python code sending the <code>SEND_TIME_DATA</code> command and storing received
    timestamps in a list.
  </p>

  <b>Results and Analysis</b>
  <p>
    After issuing the <code>SEND_TIME_DATA</code> command, all stored timestamps were successfully
    received on the laptop and appended to a Python list. The printed output shows that
    <b>76 timestamps</b> were received, with the first and last values matching the expected order,
    confirming that the entire array was transmitted correctly without data loss.
  </p>

  <!-- Result -->
  <img src="images/task6_.png" alt="Received timestamp data output">
  <p class="small">
    Figure 13: Output showing the total number of received timestamps along with the first and last
    values, verifying correct batch transmission.
  </p>
</div>

<div class="cardish">
  <h3>Task 7 — GET_TEMP_READINGS (paired timestamp + temperature arrays)</h3>

  <ul>
    <li>
      <b>Task:</b> Add a second array (same length as the timestamp array) to store temperature readings.
      Each index <code>i</code> stores a corresponding pair: <code>time_data[i]</code> was recorded at the same
      time as <code>temp_data[i]</code>. Implement <code>GET_TEMP_READINGS</code> to send paired values, and parse
      them on the laptop into two Python lists.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    On the Artemis, two global arrays with the same size are used:
    <code>time_data[]</code> stores timestamps and <code>temp_data[]</code> stores temperature readings.
    When a sample is taken, the code writes <code>time_data[idx] = millis()</code> and
    <code>temp_data[idx] = &lt;temperature&gt;</code> using the same index <code>idx</code>, ensuring that both arrays
    remain aligned (i.e., element <code>i</code> in each array is a matched pair).
  </p>
  <p>
    A new command <code>GET_TEMP_READINGS</code> loops through both arrays concurrently from
    <code>i = 0</code> to <code>i = n-1</code> and sends each pair as a single formatted string:
    <code>D:&lt;time&gt;,&lt;temp&gt;</code>. On the laptop, the notification handler checks the <code>D:</code> prefix,
    splits the payload at the comma, and appends the parsed values into two lists
    (<code>time_list</code> and <code>temp_list</code>).
  </p>

  <!-- Code: Arduino -->
  <img src="images/task7_1.png" alt="Arduino GET_TEMP_READINGS loops two arrays concurrently">
  <p class="small">
    Figure 14: <code>GET_TEMP_READINGS</code> iterates through <code>time_data[]</code> and <code>temp_data[]</code>
    using the same index and transmits paired values as <code>D:&lt;time&gt;,&lt;temp&gt;</code>.
  </p>

  <!-- Code: Python -->
  <img src="images/task7_2.png" alt="Python notification handler parses D:time,temp">
  <p class="small">
    Figure 15: Notification handler parses strings with prefix <code>D:</code>, splits into timestamp and
    temperature, and populates <code>time_list</code> and <code>temp_list</code>.
  </p>

  <b>Results and Analysis</b>
  <p>
    After sending <code>GET_TEMP_READINGS</code>, the laptop received matched timestamp–temperature pairs.
    The output shows <b>67</b> entries in both <code>time_list</code> and <code>temp_list</code>, confirming that the
    handler populated both lists consistently and that each timestamp corresponds to its temperature
    reading at the same index.
  </p>

  <!-- Result -->
  <img src="images/task7_.png" alt="Received paired timestamp-temperature data">
  <p class="small">
    Figure 16: Verification output showing equal list lengths and sample head/tail pairs, demonstrating
    correct parsing and alignment of timestamped temperature data.
  </p>
</div>

<!-- Task 8 -->
<div class="cardish">
  <h3>Task 8 — Streaming vs. Batch Transmission</h3>

  <b>Methods compared</b>
  <ul>
    <li>
      <b>Streaming (Task 5):</b> Each timestamp is sent immediately from the Artemis to the laptop using BLE notifications.
    </li>
    <li>
      <b>Batch transmission (Tasks 6 & 7):</b> Data is first stored in global arrays on the Artemis and later sent in a loop using a dedicated command.
    </li>
  </ul>

  <b>Streaming approach</b>
  <ul>
    <li><b>Advantages:</b> Immediate feedback and minimal onboard memory usage.</li>
    <li><b>Disadvantages:</b> Transmission rate is limited by BLE notification throughput.</li>
    <li>
      <b>Observed performance:</b> Approximately 180 timestamps were received over 5 seconds, corresponding to about
      <b>35 messages per second</b>, resulting in only a few kbps of effective data rate.
    </li>
  </ul>

  <b>Batch transmission approach</b>
  <ul>
    <li>
      <b>Advantages:</b> Data recording speed is independent of BLE bandwidth and is determined only by the sampling interval.
    </li>
    <li>
      <b>Disadvantages:</b> Requires additional RAM to store data and delays feedback until transmission is triggered.
    </li>
    <li>
      <b>Observed behavior:</b> All recorded samples were successfully received on the laptop
      (e.g., 76 timestamps in Task 6 and 67 timestamp–temperature pairs in Task 7).
    </li>
  </ul>

  <b>Recording speed comparison</b>
  <p>
    The second method can record data significantly faster than the BLE streaming method because it is not constrained by
    notification throughput. BLE bandwidth only becomes a limitation during the batch transfer phase.
  </p>

  <b>Memory considerations</b>
  <p>
    The Artemis board has 384 kB of RAM. Assuming 4 bytes per timestamp, approximately 98,000 timestamps could be stored.
    When storing paired timestamp and temperature data (8 bytes per sample), this corresponds to roughly 49,000 samples.
    In practice, usable capacity is slightly lower due to program variables and BLE buffers.
  </p>
</div>


    </section>

    <!-- 4) Discussion -->
    <section id="discussion" class="cardish">

  <ul>
    <li>
      <b>What I learned:</b> BLE notification throughput is a practical bottleneck for real-time
      streaming, while buffering data locally enables reliable high-rate recording.
    </li>
    <li>
      <b>Challenges:</b> Achieving stable timing without blocking the main loop and correctly
      handling asynchronous notifications on the Python side.
    </li>
    <li>
      <b>Solutions:</b> Using <code>millis()</code>-based non-blocking loops and global arrays to
      buffer data, followed by batch transmission with verification on the laptop.
    </li>
  </ul>
</div>

    </section>

    <!-- 5) 5000-level optional -->
    <section id="grad" class="cardish">
      <h2>5. 5000-level (Optional): Communication Performance Analysis</h2>
      <p class="small">
        If you are doing the 5000-level tasks, include at least one plot and answer reliability at higher rates. :contentReference[oaicite:14]{index=14}
      </p>

      <div class="cardish">
        <h3>5.1 Effective Data Rate & Overhead (5B vs 120B replies)</h3>
        <p><span class="pill pill-todo">TODO</span>
          Describe your experiment: PC sends request, Artemis replies fixed-size payloads; record send/receive times; compute data rate.
        </p>
        <ul>
          <li>Reply sizes tested: <span class="pill pill-todo">TODO</span></li>
          <li>Data rate results: <span class="pill pill-todo">TODO</span></li>
          <li>Conclusion about overhead: <span class="pill pill-todo">TODO</span></li>
        </ul>
        <img src="images/TODO_overhead_plot.png" alt="TODO: overhead plot"/>
        <p class="small">Figure: <span class="pill pill-todo">TODO</span> caption.</p>
      </div>

      <div class="cardish">
        <h3>5.2 Reliability (high-rate notifications)</h3>
        <p><span class="pill pill-todo">TODO</span>
          What happens when sending at a higher rate? Does the computer miss messages?
          Explain how you tested and what you observed. :contentReference[oaicite:15]{index=15}
        </p>
      </div>
    </section>

    <!-- 6) References -->
    <section id="refs" class="cardish">
      <h2>6. References</h2>
      <ul>
        <li>Fast Robots 2026 — Lab 1 Handout</li>
        <li>ArduinoBLE documentation</li>
        <li>Bleak documentation (Python BLE)</li>
      </ul>
      <p class="small">Last updated: <span class="pill pill-todo">TODO</span></p>
    </section>

    <hr/>
    <p class="small">
      Tip: Put your images under <code>labs/images/</code> (same folder level as <code>lab1.html</code>) and link like:
      <code>&lt;img src="images/your_plot.png"&gt;</code>
    </p>
  </div>
</body>
</html>























