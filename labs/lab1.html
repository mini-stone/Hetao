<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lab 1 | Artemis and Bluetooth</title>

  <!-- Match your site theme -->
  <link href="../css/styles.css" rel="stylesheet" />

  <style>
    /* Simple readable lab-page styling on top of your theme */
    .lab-container { max-width: 980px; margin: 0 auto; padding: 2rem 1rem; }
    .lab-title { margin-top: 1rem; }
    .pill { display:inline-block; padding:.2rem .6rem; border-radius:999px; font-size:.85rem; }
    .pill-ok { background:#e8f5e9; }
    .pill-todo { background:#fff3e0; }
    .cardish { border: 1px solid rgba(0,0,0,.12); border-radius: 12px; padding: 1rem; margin: 1rem 0; }
    pre { background: rgba(0,0,0,.05); padding: .9rem; border-radius: 10px; overflow:auto; }
    code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    img { max-width: 100%; border-radius: 10px; }
    .small { color: rgba(0,0,0,.65); font-size: .95rem; }
    .toc a { text-decoration: none; }
    .toc a:hover { text-decoration: underline; }
    table { width:100%; border-collapse: collapse; margin: .75rem 0; }
    th, td { border: 1px solid rgba(0,0,0,.15); padding: .5rem; text-align:left; vertical-align: top; }
    th { background: rgba(0,0,0,.05); }
  </style>
</head>

<body>
  <div class="lab-container">
    <!-- Header -->
    <a href="../index.html">← Back to Home</a>

    <h1 class="lab-title">Lab 1: The Artemis Board and Bluetooth</h1>
    <p class="small">
      Course: ECE 5160 Fast Robots (Spring 2026) <br/>
      Student: Hetao Yin <br/>
    </p>

    <div class="cardish toc">
      <b>Table of Contents</b>
      <ol>
        <li><a href="#overview">Overview</a></li>
        <li><a href="#prelab">Prelab</a></li>
        <li><a href="#tasks">Lab Tasks (1–8)</a></li>
        <li><a href="#discussion">Discussion</a></li>
        <li><a href="#grad">5000-level (Optional)</a></li>
        <li><a href="#refs">References</a></li>
      </ol>
      <p class="small">
        NOTE: Keep the final write-up under <b>1000 words</b> (excluding code blocks/captions if you want to be safe). :contentReference[oaicite:1]{index=1}
      </p>
    </div>

    <!-- 1) Overview -->
    <section id="overview" class="cardish">
      <h2>1. Overview</h2>
      <p>
        This lab introduces the SparkFun RedBoard Artemis Nano and establishes a basic
Bluetooth Low Energy (BLE) communication pipeline between the Artemis board and a
host computer. In Lab 1A, the Arduino development environment was set up and basic
Artemis programming tasks were completed to verify correct board configuration and
serial communication. In Lab 1B, a BLE-based communication framework was implemented,
allowing a laptop (Python/Jupyter) to act as a central device and exchange commands
and data with the Artemis board acting as a peripheral. This framework forms the
foundation for reliable data transmission and command-based interaction used in
subsequent labs.

      <h3>Hardware / Software</h3>
      <ul>
        <li><b>Board:</b> SparkFun RedBoard Artemis Nano</li>
        <li><b>IDE:</b> Arduino IDE</li>
        <li><b>Python:</b> venv + JupyterLab + bleak (BLE)</li>
      </ul>

    </section>

    <!-- 2) Prelab -->
    <section id="prelab" class="cardish">
      <h2>2. Prelab</h2>

      <h3>2.1 Blink</h3>
      <p>
      <video width="480" controls>
  <source src="videos/blink.mp4" type="video/mp4">
  Your browser does not support the video tag.
</video>

<p class="small">  
      </p>

<h3>2.2 Serial</h3>
      <p>
<img src="images/serial.png" alt="Serial monitor output for blink test">

<p class="small">
    </p>    
      <h3>2.3 AnalogRead</h3>
      <p>
<img src="images/analogRead.png" alt="Analog read output">

<p class="small">

    </p>  
      <h3>2.4 MircrophoneOut</h3>
      <p>
<img src="images/MicrophoneOutput.png" alt="Microphone output values">

<p class="small">
    </p>  
      </div>


    </section>

    <!-- 3) Tasks -->
    <section id="tasks" class="cardish">
      <h2>3. Lab Tasks</h2>
      <p class="small">
        Below follows tasks 1–8 required by the Lab 1B handout. For each task:
        explain what you changed, show evidence (screenshot/video), and include minimal code snippets. :contentReference[oaicite:4]{index=4}
      </p>

      <!-- Task 1 -->
<div class="cardish">
  <h3>Task 1 — ECHO string (PC → Artemis → PC)</h3>

  <ul>
    <li><b>Command used:</b> <code>ECHO</code></li>
    <li><b>Expected behavior:</b> The PC sends a string to the Artemis board, and the Artemis replies with an augmented version of the string.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task1.png" alt="ECHO command code">
    <p class="small">Figure 1: Arduino-side ECHO handling and reply construction.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task1_.png" alt="ECHO command output">
    <p class="small">Figure 2: ECHO command sent from the PC and augmented reply received from Artemis.</p>
  </div>
</div>

<!-- Task 2 -->
<div class="cardish">
  <h3>Task 2 — SEND_THREE_FLOATS (extract 3 floats on Artemis)</h3>

  <ul>
    <li><b>Command used:</b> <code>SEND_THREE_FLOATS</code></li>
    <li><b>Expected behavior:</b> The PC sends three float values, and the Artemis parses and prints/returns the extracted floats.</b></li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task2.png" alt="SEND_THREE_FLOATS code">
    <p class="small">Figure 3: Arduino-side parsing of three floats using RobotCommand/EString.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task2_.png" alt="SEND_THREE_FLOATS output">
    <p class="small">Figure 4: Sending three floats from the PC and confirming the parsed values on Artemis.</p>
  </div>
</div>


     <!-- Task 3 -->
<div class="cardish">
  <h3>Task 3 — GET_TIME_MILLIS (reply “T:123456”)</h3>

  <ul>
    <li><b>Command used:</b> <code>GET_TIME_MILLIS</code></li>
    <li><b>Expected behavior:</b> The Artemis returns the current timestamp (in milliseconds) formatted as <code>T:&lt;millis&gt;</code> over BLE.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Arduino)</b>
    <img src="images/task3.png" alt="GET_TIME_MILLIS code">
    <p class="small">Figure 5: Arduino-side GET_TIME_MILLIS command handling and timestamp string formatting.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task3_.png" alt="GET_TIME_MILLIS output">
    <p class="small">Figure 6: GET_TIME_MILLIS request sent from the PC and <code>T:&lt;millis&gt;</code> response received from Artemis.</p>
  </div>
</div>

      <!-- Task 4 -->
<div class="cardish">
  <h3>Task 4 — Python notification handler (parse time from string)</h3>

  <ul>
    <li><b>Task:</b> Set up a BLE notification handler in Python to receive the Artemis TX string characteristic.</li>
    <li><b>Expected behavior:</b> The callback decodes the incoming string and extracts the timestamp from messages formatted as <code>T:&lt;millis&gt;</code>.</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation (Python)</b>
    <img src="images/task4.png" alt="Python notification handler code">
    <p class="small">Figure 7: Python notification callback implementation for receiving and parsing <code>T:&lt;millis&gt;</code> strings.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Evidence (Python/Jupyter)</b>
    <img src="images/task4_.png" alt="Notification output showing parsed timestamps">
    <p class="small">Figure 8: Notifications received from Artemis and timestamps successfully extracted in the callback.</p>
  </div>
</div>

<div class="cardish">
  <h3>Task 5 — Timestamp streaming & data rate</h3>

  <ul>
    <li>
      <b>Task:</b> Continuously send the current timestamp from the Artemis to the laptop using BLE
      notifications and determine the effective data transfer rate.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    A non-blocking loop on the Artemis uses <code>millis()</code> to periodically send the current
    timestamp as a BLE notification. On the laptop, a Python notification handler extracts the
    timestamp and counts how many messages are received over a fixed time window.
  </p>

  <!-- Code -->
  <img src="images/task5.png" alt="Arduino timestamp loop and Python handler code">
  <p class="small">
    Figure 9: Arduino loop transmitting <code>millis()</code> timestamps and Python notification handler.
  </p>

  <!-- Result -->
  <img src="images/task5_.png" alt="Timestamp output and rate calculation">
  <p class="small">
    Figure 10: Consecutive timestamps received on the laptop and calculated message rate.
  </p>

  <b>Results and Analysis</b>
  <p>
    Over approximately 5 seconds, 180 timestamp messages were received, corresponding to an average
    rate of <b>~35 messages per second</b>. Each message contains a timestamp string of about 8 bytes,
    resulting in an effective data transfer rate of approximately <b>2 kbps</b>.
  </p>
</div>


     <div class="cardish">
  <h3>Task 6 — Store timestamps in an array and send in batch</h3>

  <ul>
    <li>
      <b>Task:</b> Store timestamp data on the Artemis in a global array, then transmit the entire
      dataset to the laptop using a dedicated BLE command.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    A global array is defined on the Artemis to store timestamp values generated using
    <code>millis()</code>. During normal operation, the main loop periodically records timestamps
    into this array instead of immediately sending them over BLE. An index variable is used to
    track the current position in the array, and additional logic ensures the array is not overfilled.
  </p>
  <p>
    Once the array is full, a new command (<code>SEND_TIME_DATA</code>) is used to iterate through
    the stored timestamps and send each value as a string over a BLE notification. This allows
    timestamp data to be transmitted in a batch rather than continuously.
  </p>

  <!-- Code: Arduino -->
  <img src="images/task6_1.png" alt="Arduino timestamp array and SEND_TIME_DATA command">
  <p class="small">
    Figure 11: Arduino implementation showing a global timestamp array, controlled insertion logic,
    and the <code>SEND_TIME_DATA</code> command used to transmit stored values.
  </p>

  <!-- Code: Python -->
  <img src="images/task6_2.png" alt="Python code collecting timestamp data">
  <p class="small">
    Figure 12: Python code sending the <code>SEND_TIME_DATA</code> command and storing received
    timestamps in a list.
  </p>

  <b>Results and Analysis</b>
  <p>
    After issuing the <code>SEND_TIME_DATA</code> command, all stored timestamps were successfully
    received on the laptop and appended to a Python list. The printed output shows that
    <b>76 timestamps</b> were received, with the first and last values matching the expected order,
    confirming that the entire array was transmitted correctly without data loss.
  </p>

  <!-- Result -->
  <img src="images/task6_.png" alt="Received timestamp data output">
  <p class="small">
    Figure 13: Output showing the total number of received timestamps along with the first and last
    values, verifying correct batch transmission.
  </p>
</div>

<div class="cardish">
  <h3>Task 7 — GET_TEMP_READINGS (paired timestamp + temperature arrays)</h3>

  <ul>
    <li>
      <b>Task:</b> Add a second array (same length as the timestamp array) to store temperature readings.
      Each index <code>i</code> stores a corresponding pair: <code>time_data[i]</code> was recorded at the same
      time as <code>temp_data[i]</code>. Implement <code>GET_TEMP_READINGS</code> to send paired values, and parse
      them on the laptop into two Python lists.
    </li>
  </ul>

  <b>Implementation</b>
  <p>
    On the Artemis, two global arrays with the same size are used:
    <code>time_data[]</code> stores timestamps and <code>temp_data[]</code> stores temperature readings.
    When a sample is taken, the code writes <code>time_data[idx] = millis()</code> and
    <code>temp_data[idx] = &lt;temperature&gt;</code> using the same index <code>idx</code>, ensuring that both arrays
    remain aligned (i.e., element <code>i</code> in each array is a matched pair).
  </p>
  <p>
    A new command <code>GET_TEMP_READINGS</code> loops through both arrays concurrently from
    <code>i = 0</code> to <code>i = n-1</code> and sends each pair as a single formatted string:
    <code>D:&lt;time&gt;,&lt;temp&gt;</code>. On the laptop, the notification handler checks the <code>D:</code> prefix,
    splits the payload at the comma, and appends the parsed values into two lists
    (<code>time_list</code> and <code>temp_list</code>).
  </p>

  <!-- Code: Arduino -->
  <img src="images/task7_1.png" alt="Arduino GET_TEMP_READINGS loops two arrays concurrently">
  <p class="small">
    Figure 14: <code>GET_TEMP_READINGS</code> iterates through <code>time_data[]</code> and <code>temp_data[]</code>
    using the same index and transmits paired values as <code>D:&lt;time&gt;,&lt;temp&gt;</code>.
  </p>

  <!-- Code: Python -->
  <img src="images/task7_2.png" alt="Python notification handler parses D:time,temp">
  <p class="small">
    Figure 15: Notification handler parses strings with prefix <code>D:</code>, splits into timestamp and
    temperature, and populates <code>time_list</code> and <code>temp_list</code>.
  </p>

  <b>Results and Analysis</b>
  <p>
    After sending <code>GET_TEMP_READINGS</code>, the laptop received matched timestamp–temperature pairs.
    The output shows <b>67</b> entries in both <code>time_list</code> and <code>temp_list</code>, confirming that the
    handler populated both lists consistently and that each timestamp corresponds to its temperature
    reading at the same index.
  </p>

  <!-- Result -->
  <img src="images/task7_.png" alt="Received paired timestamp-temperature data">
  <p class="small">
    Figure 16: Verification output showing equal list lengths and sample head/tail pairs, demonstrating
    correct parsing and alignment of timestamped temperature data.
  </p>
</div>

<!-- Task 8 -->
<div class="cardish">
  <h3>Task 8 — Streaming vs. Batch Transmission</h3>

  <b>Methods compared</b>
  <ul>
    <li>
      <b>Streaming (Task 5):</b> Each timestamp is sent immediately from the Artemis to the laptop using BLE notifications.
    </li>
    <li>
      <b>Batch transmission (Tasks 6 & 7):</b> Data is first stored in global arrays on the Artemis and later sent in a loop using a dedicated command.
    </li>
  </ul>

  <b>Streaming approach</b>
  <ul>
    <li><b>Advantages:</b> Immediate feedback and minimal onboard memory usage.</li>
    <li><b>Disadvantages:</b> Transmission rate is limited by BLE notification throughput.</li>
    <li>
      <b>Observed performance:</b> Approximately 180 timestamps were received over 5 seconds, corresponding to about
      <b>35 messages per second</b>, resulting in only a few kbps of effective data rate.
    </li>
  </ul>

  <b>Batch transmission approach</b>
  <ul>
    <li>
      <b>Advantages:</b> Data recording speed is independent of BLE bandwidth and is determined only by the sampling interval.
    </li>
    <li>
      <b>Disadvantages:</b> Requires additional RAM to store data and delays feedback until transmission is triggered.
    </li>
    <li>
      <b>Observed behavior:</b> All recorded samples were successfully received on the laptop
      (e.g., 76 timestamps in Task 6 and 67 timestamp–temperature pairs in Task 7).
    </li>
  </ul>

  <b>Recording speed comparison</b>
  <p>
    The second method can record data significantly faster than the BLE streaming method because it is not constrained by
    notification throughput. BLE bandwidth only becomes a limitation during the batch transfer phase.
  </p>

  <b>Memory considerations</b>
  <p>
    The Artemis board has 384 kB of RAM. Assuming 4 bytes per timestamp, approximately 98,000 timestamps could be stored.
    When storing paired timestamp and temperature data (8 bytes per sample), this corresponds to roughly 49,000 samples.
    In practice, usable capacity is slightly lower due to program variables and BLE buffers.
  </p>
</div>


    </section>

    <!-- 4) Discussion -->
    <section id="discussion" class="cardish">

  <ul>
    <li>
      <b>What I learned:</b> BLE notification throughput is a practical bottleneck for real-time
      streaming, while buffering data locally enables reliable high-rate recording.
    </li>
    <li>
      <b>Challenges:</b> Achieving stable timing without blocking the main loop and correctly
      handling asynchronous notifications on the Python side.
    </li>
    <li>
      <b>Solutions:</b> Using <code>millis()</code>-based non-blocking loops and global arrays to
      buffer data, followed by batch transmission with verification on the laptop.
    </li>
  </ul>
</div>

</div>

    </section>

    <!-- 5) 5000-level optional -->
    <section id="grad" class="cardish">
      <h2>5. 5000-level (Optional): Communication Performance Analysis</h2>
     <!-- Extra_Task_1 — Effective Data Rate and Overhead -->
<div class="cardish">
  <h3> Effective Data Rate and Overhead (PC ↔ Artemis)</h3>

  <ul>
    <li><b>Goal:</b> Measure round-trip time (RTT) for a request–reply exchange and compute the effective data rate for different reply sizes (at least 5B and 120B).</li>
    <li><b>Key questions:</b> Do short packets suffer large overhead? Do larger replies amortize that overhead and improve throughput?</li>
  </ul>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Method</b>
    <ul>
      <li><b>RTT measurement:</b> On the laptop, record <code>t_send</code> immediately before sending a command, and record <code>t_recv</code> inside the BLE notification handler when the reply arrives. Then
        <code>RTT = t_recv - t_send</code>.
      </li>
      <li><b>Why PC timestamps:</b> Using the same PC clock for send/receive avoids cross-device clock mismatch (Artemis <code>millis()</code> cannot be directly subtracted from PC time).</li>
      <li><b>Effective data rate:</b> For a reply payload length <code>N</code> bytes,
        <code>rate(N) = N / mean(RTT(N))</code> in bytes/sec, where <code>mean(RTT(N))</code> is averaged over repeated trials.
      </li>
      <li><b>Sanity check:</b> Log the received payload length on the laptop to confirm <code>rx_len_mean ≈ N</code> for each test size.</li>
    </ul>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Implementation Notes</b>
    <ul>
      <li><b>Artemis:</b> Add a command that returns a string payload of exactly <code>N</code> bytes via the TX string characteristic (notify), so different reply sizes can be tested under the same request–reply flow.</li>
      <li><b>Python:</b> Store <code>t_send</code> and the pending <code>N</code> before sending. In the notification callback, compute RTT, append it to a per-<code>N</code> log, and record <code>len(data)</code> for verification.</li>
    </ul>

   <img src="images/extra_1.png" alt="caculate and send N">
    <p class="small">Figure 17. Code used to the length of DATA and send to computer.</p>
    <img src="images/extra_2.png" alt="RTT">
    <p class="small">Figure 18. Code used to timestamp send/receive events and compute RTT inside the notification handler (with payload length verification).</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Results</b>
    <p class="small" style="margin-bottom:.5rem;">
      The table below summarizes the measured mean RTT and effective rate for several reply sizes. (Each size was repeated multiple times and averaged.)
    </p>

    <!-- You can keep this table or replace with your exact summary printout -->
    <table>
      <thead>
        <tr>
          <th>Reply length N (bytes)</th>
          <th>Mean RTT (ms)</th>
          <th>Effective rate (bytes/s)</th>
          <th>rx_len_mean (bytes)</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>5</td>
          <td>~233</td>
          <td>~21</td>
          <td>~5</td>
        </tr>
        <tr>
          <td>120</td>
          <td>~233</td>
          <td>~515</td>
          <td>~120</td>
        </tr>
        <!-- Add your other tested sizes here (20/40/60/80/100) -->
      </tbody>
    </table>

    <!-- FIGURE PLACEHOLDER: screenshot of your printed summary output -->
    <img src="images/dat_1.png" alt="RTT summary output">
    <p class="small">Figure 19. Console summary of RTT statistics and computed effective data rate for each reply length.</p>

    <!-- FIGURE PLACEHOLDER: Effective Data Rate vs Reply Length plot -->
    <img src="images/data_2.png" alt="Effective Data Rate vs Reply Length">
    <p class="small">Figure 20. Effective data rate increases with reply length, indicating fixed per-message overhead dominates RTT.</p>

    <!-- FIGURE PLACEHOLDER: RTT vs Reply Length plot (with error bars) -->
    <img src="images/data_3.png" alt="RTT vs Reply Length">
    <p class="small">Figure 21. RTT stays roughly in the 200–240 ms range across reply sizes, suggesting payload size has a smaller effect than protocol/stack overhead.</p>
  </div>

  <div class="cardish" style="margin-top:.75rem;">
    <b>Answers to the prompt</b>
    <ul>
      <li>
        <b>Data rate for 5-byte replies:</b> Using the measured mean RTT (~233 ms), the effective rate is
        approximately <b>~21 bytes/s</b> (≈ 5 / 0.233).
      </li>
      <li>
        <b>Data rate for 120-byte replies:</b> With a similar RTT (~233 ms), the effective rate increases to
        approximately <b>~515 bytes/s</b> (≈ 120 / 0.233).
      </li>
      <li>
        <b>Do many short packets introduce overhead?</b> Yes. RTT remains ~constant even when the reply is only a few bytes,
        so the fixed per-packet BLE/OS/protocol overhead dominates and makes small payloads inefficient.
      </li>
      <li>
        <b>Do larger replies reduce overhead?</b> Yes. Since RTT does not increase proportionally with payload size in this range,
        sending more bytes per reply amortizes the fixed overhead, producing a much higher effective data rate.
      </li>
    </ul>
  </div>
</div>
<div class="cardish" style="margin-top:.75rem;">
  <b>Reliability (high-rate streaming)</b>
  <p>
    When I increased the notification send rate from the Artemis to the laptop, the laptop did <b>not</b> reliably read
    every published data point. The receive rate becomes limited by BLE/OS overhead: in Task 5, over ~5 seconds I only
    received about <b>180</b> timestamps (≈ <b>35 msg/s</b>). Therefore, if the Artemis publishes faster than this practical
    throughput, the laptop will fall behind and intermediate updates can be missed. In contrast, the batch method in
    Tasks 6/7 (store in arrays first, then transmit with a command) is more reliable because the Python lists can be
    checked to confirm the full dataset was received.
  </p>
    </section>

    <!-- 6) References -->
    <section id="refs" class="cardish">
      <h2>6. References</h2>
      <ul>
        <li>Fast Robots 2026 — Lab 1 Handout</li>
        <li>ArduinoBLE documentation</li>
        <li>Bleak documentation (Python BLE)</li>
      </ul>
      
    </section>

    <hr/>
    
  </div>
</body>
</html>




























